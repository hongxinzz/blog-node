---
##title:浅谈面向对象实例。-title
##introduction:面向对象的实例方法以及区别。-introduction
##time:2018-04-1-time
##cover:https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1543555608105&di=2c626d0963249618ed520b35b9f1fb9e&imgtype=0&src=http%3A%2F%2Fp0.qhimg.com%2Ft01d33574ff8f0f445c.gif-cover
##tags:javaScript-tags
---
##content:
###先来谈谈对象：
```javascript
// 比如现在有三个人物，且他们拥有的属性不一样，通常的做法就是通过对象的形式就行表达
var person1 = {
    name:'xiaohong',
    age:18,
    sex:'gril'
}
var person2 = {
    name:'xiaoming',
    age:16,
    sex:'boy'
}
var person3 = {
    name:'niudun',
    age:19,
    sex:'boy'
}
```
- 在上个例子中我们发现，如果我们要创建三个不同的人物，就要分别去用三个对象进行包装。所以就有了面向对象的方式进行封装
```javascript
// 面向对象工厂模式
function createPerson(name,age,sex){
    var o  =  new Object();
    o.name = name;
    o.age = age;
    o.sex = sex;
    return o
}
// 当然等价于下面这样子
function createPerson(name,age,sex){
    return{
        name:name,
        age:age,
        sex:sex,
    }
}
var cretaPerson1 = createPerson('xiaohong',18,'gril');
var cretaPerson2 = createPerson('xiaoming',16,'boy');
var cretaPerson3 = createPerson('niudun',19,'boy');

// 上面代码中我们通过一个createPerson的函数，每一次调用都会返回一个包含三个属性的对象。
```
- 工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)
###构造函数
```javascript
function Person(name, age, sex){//按照惯例构造函数的首字母因该大写
        this.name = name;
        this.age = age;
        this.sex = sex;
}
var person1 = new Person("xiaoming", 16, "boy");
var person2 = new Person("xiaohong", 18, "gril");
```
####与工厂模式不同的是，我们在Person中没有:
1.没有显明的对象声明
2.Person直接将方法和属性赋值给this
3.没有return语句
####并且我们创建一个实例 new的时候发生了以下情况:
1.new的时候创建了一个新的对象
2.将this指向了该对象
3.为对象添加了Person的属性
4.返回了新的对象
```javascript
 // 在控制台中我们可以输出person1，他constructor(构造函数)指向了我们Person函数并且有三个对象
 console.log(person1.constructor == Person); //true
 console.log(person2.constructor == Person); //true
 Person {name: "xiaoming", age: 16, sex: "boy"}
 person1.name //xiaoming
 person1.age //16
 person1.sex //boy
 //在工厂模式中我们说明了 工厂模式我们不容易分辨出或者证明他是一个对象 但是在构造函数中就解决这个问题
 //我们可以通过 instanceof 操作符来验证
 console.log(person1 instanceof Object);  //true
 console.log(person2 instanceof Object);  //true
```
- 在构造函数中我们解决了不是对象的问题，但是构造函数也有不足
 ```javascript
function Person(name, age, sex){//按照惯例构造函数的首字母因该大写
        this.name = name;
        this.age = age;
        this.sex = sex;
        //this.sayHello = new Function('console.log('hello')')
        this.sayHello = function () {
          console.log('hello')
        }
}
var person1 = new Person("xiaoming", 16, "boy");
var person2 = new Person("xiaohong", 18, "gril");

// 在上面的new中 我们同一个功能被重复new一个方法，
// 功能相同的函数，重复声明消耗空间，并且浪费不必要的内存
```
###prototype
- prototype?这是什么东西？
- prototype是函数的一个属性，是一个对象。并且有读写功能
```javascript
function  Person() {
    this.sayName = function() {
    }
}
console.log(Person.prototype);  //Object
Person.prototype.name = 'xiaoming';
Person.prototype.sex = 'boy';
Person.prototype.age = 18;
Person.prototype.sayHello = function() {
        console.log('hello')
}
var person = new Person();
console.log(person.name) //xiaoming
console.log(person.sex) //boy

var person2 = new Person();

// 进行对比共同函数对比
console.log(person.sayHello === person2.sayHello) //true
console.log(person.sayName === person2.sayName) //false
```
-content
